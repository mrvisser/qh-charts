{"version":3,"sources":["hooks/useObservable.ts","services/MetricsStore.ts","components/Charts.tsx","services/FileStore.ts","components/FileDropZone.tsx","App.tsx","reportWebVitals.ts","setupVendorLibraries.ts","index.tsx"],"names":["useObservable","observableGenerator","deps","initialValue","React","useState","value","setValue","cb","useCallback","useEffect","o","undefined","sub","subscribe","error","err","console","next","unsubscribe","MetricsStoreContext","createContext","MetricsStore","fileStore","customerDataTimeZone$$","BehaviorSubject","bloodGlucose$","combineLatest","this","filesByType$","pipe","concatMap","files","customerDataTimeZone","of","Promise","resolve","a","csvs","map","file","data","atob","bytes","Uint8Array","length","i","charCodeAt","TextDecoder","decode","replaceAll","all","parseBloodGlucoseCsv","timeValuesArr","timeValues","reduce","acc","m","Object","keys","timeStr","str","tz","time","moment","valueOf","sort","b","fn","input","accept","reject","csvParse","split","slice","join","columns","records","result","record","parseValue","parseFloat","isNaN","metricValuesToHighchartsPairs","ms","ExcludePrint","styled","div","ChartsContainer","ChartsHeading","h1","DateRangePickerContainer","PageGroup","ChartContainer","ChartHeading","h2","Chart","Charts","timezone","divProps","metricsStore","useContext","dayFilter","setDayFilter","overallBloodGlucose","overallMinMaxTime","setOverallMinMaxTime","overallHighchartsOptions","useMemo","createHighchartsOptionsOverall","max","min","overallHighchartsFilterOptions","start","end","dailyBloodGlucose","_","chain","groupBy","format","toPairs","day","sortBy","dailyMinMaxDay","nDays","dailyHighchartsOptions","chunk","filter","startDate","endDate","dayMoment","isSameOrAfter","isSameOrBefore","xMinMax","endOf","toDate","getTime","startOf","yMax","Math","d","yMinMax","ceil","hidden","options","createHighchartsOptionsForDay","title","id","constructorType","highcharts","HighchartsStock","Highcharts","minDate","maxDate","moveRangeOnFirstSelection","onChange","range","selection","ranges","key","showSelectionPreview","pageGroup","concat","Array","fill","chart","events","className","onRangeChange","rangeChangeTimeout","animation","height","margin","style","fontFamily","type","colors","credits","enabled","legend","plotOptions","series","gapSize","gapUnit","marker","name","text","xAxis","dateTimeLabelFormats","week","setExtremes","ev","clearTimeout","setTimeout","labels","rotation","ordinal","yAxis","plotBands","color","from","to","tickInterval","values","p","dayMax","dayAvg","round","v","dayMin","timeExposed","calculateTimeInRange","lower","timeInRange","upper","render","forEach","l","destroy","chartPaddingTop","valueX","labelX","attrs","zIndex","renderer","add","attr","x","y","duration","maxLabel","maxValue","toString","avgLabel","avgValue","teLabel","teValue","push","radius","plotLines","compact","dashStyle","width","Number","MIN_VALUE","MAX_VALUE","currTime","currValue","prevTime","prevValue","currValueLimited","prevValueLimited","areaOfData","abs","areaInRange","FileStoreContext","FileStore","files$$","files$","asObservable","fs","f","fileList","unsupported","fileListItem","item","preProcessFileData","arrayBuffer","url","fetch","response","contentType","headers","get","uniqBy","readData","resolveFileType","buffer","btoa","byte","String","fromCharCode","size","byteLength","startsWith","endsWith","Container","FileDropZone","children","fileService","fileUploadEl","setFileUploadEl","handleSelectFiles","preProcessFiles","preProcessed","acceptFiles","onClick","click","onDragOver","preventDefault","stopPropagation","onDrop","dataTransfer","cursor","multiple","target","ref","el","display","GlobalStyle","createGlobalStyle","reset","Fullscreen","App","dataUrl","csvFiles","preProcessUrl","Provider","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","brokenAxis","URLSearchParams","window","location","search","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e2451f54.chunk.js","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\nimport React from 'react';\nimport { Observable } from 'rxjs/internal/Observable';\n\nexport type ObserverFunction<T> = () => Observable<T> | undefined;\n\n/** @see [useObservable(observableGenerator, deps, initialvalue?)] */\nexport function useObservable<T>(\n  observableGenerator: ObserverFunction<T>,\n  deps: React.DependencyList,\n): [T | undefined];\n\n/** @see [useObservable(observableGenerator, deps, initialvalue?)] */\nexport function useObservable<T>(\n  observableGenerator: ObserverFunction<T>,\n  deps: React.DependencyList,\n  initialValue: T,\n): [T];\n\n/**\n * A custom hook that exposes an observable as its latest emitted value.\n *\n * @param observableGenerator A factory function for the observable\n * @param deps The dependency array. When any of these dependencies changes, the observable will\n *   be regenerated.\n * @param initialValue The initial value of the observable value, before it emits its first value.\n *   When the dependency array changes, the value will not revert to the initial value.\n * @returns\n */\nexport function useObservable<T>(\n  observableGenerator: ObserverFunction<T>,\n  deps: React.DependencyList,\n  initialValue?: T,\n): [typeof initialValue] {\n  const [value, setValue] =\n    React.useState<T | typeof initialValue>(initialValue);\n  const cb = React.useCallback(observableGenerator, deps);\n\n  /** When the callback changes, reinvoke it and subscribe to the new observable. */\n  React.useEffect(() => {\n    const o = cb();\n    if (o !== undefined) {\n      // eslint-disable-next-line deprecation/deprecation\n      const sub = o.subscribe({\n        // eslint-disable-next-line no-console\n        error: (err) => console.error(err),\n        next: setValue,\n      });\n      return () => sub.unsubscribe();\n    }\n  }, [cb]);\n\n  return [value];\n}\n","import csvParse from 'csv-parse';\nimport moment from 'moment-timezone';\nimport React from 'react';\nimport { BehaviorSubject, combineLatest, Observable, of } from 'rxjs';\nimport { concatMap } from 'rxjs/operators';\n\nimport { FileStore } from './FileStore';\n\nexport type MetricValue<T> = {\n  time: number;\n  value: T;\n};\n\ntype CsvRecord = {\n  'Device Timestamp': string;\n  'Record Type': string;\n  'Historic Glucose mmol/L': string;\n  'Scan Glucose mmol/L': string;\n};\n\nexport const MetricsStoreContext = React.createContext<MetricsStore>(\n  undefined as unknown as MetricsStore,\n);\n\nexport class MetricsStore {\n  public static metricValuesToHighchartsPairs = <T>(\n    ms: MetricValue<T>[] | undefined,\n  ): [number, T][] | undefined => {\n    return ms !== undefined\n      ? ms.map(({ time, value }) => [time, value])\n      : undefined;\n  };\n\n  private customerDataTimeZone$$ = new BehaviorSubject('America/Toronto');\n\n  constructor(private readonly fileStore: FileStore) {}\n\n  /** Observe changes to the blood glucose metrics. */\n  public readonly bloodGlucose$: Observable<MetricValue<number>[] | undefined> =\n    combineLatest([\n      this.fileStore.filesByType$('csv'),\n      this.customerDataTimeZone$$,\n    ])\n      .pipe(\n        concatMap(([files, customerDataTimeZone]) =>\n          of<() => Promise<MetricValue<number>[] | undefined>>(\n            // Whenever we get a new set of files, first emit undefined to signal that we should\n            // enter a loading / \"stale\" state for all consumers\n            () => Promise.resolve(undefined),\n            async () => {\n              const csvs = files.map((file) => {\n                const data = atob(file.data);\n                const bytes = new Uint8Array(data.length);\n                for (let i = 0; i < data.length; i++) {\n                  bytes[i] = data.charCodeAt(i);\n                }\n                return new TextDecoder('utf-8')\n                  .decode(bytes)\n                  .replaceAll('\\r\\n', '\\n');\n              });\n              const timeValuesArr: Record<string, number>[] = await Promise.all(\n                csvs.map(parseBloodGlucoseCsv),\n              );\n              const timeValues = timeValuesArr.reduce(\n                (acc, m) => ({ ...acc, ...m }),\n                {},\n              );\n              return Object.keys(timeValues)\n                .map((timeStr) => {\n                  const value = timeValues[timeStr];\n                  const time = parseTime(timeStr, customerDataTimeZone);\n                  return { time, value };\n                })\n                .sort((a, b) => a.time - b.time);\n            },\n          ),\n        ),\n      )\n      .pipe(concatMap((fn) => fn()));\n}\n\nfunction parseBloodGlucoseCsv(input: string): Promise<Record<string, number>> {\n  return new Promise((accept, reject) => {\n    csvParse(\n      input.split('\\n').slice(1).join('\\n'),\n      { columns: true },\n      (err, records: CsvRecord[]) => {\n        if (err !== undefined) {\n          return reject(err);\n        }\n\n        const result: Record<string, number> = {};\n        for (const record of records) {\n          const value = parseValue(record);\n          if (value !== undefined) {\n            result[record['Device Timestamp']] = value;\n          }\n        }\n\n        accept(result);\n      },\n    );\n  });\n}\n\nfunction parseTime(str: string, tz: string): number {\n  return moment.tz(str, 'DD-MM-YYYY HH:mm', tz).valueOf();\n}\n\nfunction parseValue(record: CsvRecord): number | undefined {\n  const value =\n    record['Record Type'] === '0'\n      ? parseFloat(record['Historic Glucose mmol/L'])\n      : parseFloat(record['Scan Glucose mmol/L']);\n  if (!isNaN(value)) {\n    return value;\n  } else {\n    return undefined;\n  }\n}\n","import * as Highcharts from 'highcharts';\nimport HighchartsReact from 'highcharts-react-official';\nimport * as HighchartsStock from 'highcharts/highstock';\nimport _ from 'lodash';\nimport moment from 'moment-timezone';\nimport React from 'react';\nimport { DateRangePicker, Range } from 'react-date-range';\nimport { map } from 'rxjs/operators';\nimport styled from 'styled-components';\n\nimport { useObservable } from '../hooks/useObservable';\nimport { MetricsStore, MetricsStoreContext } from '../services/MetricsStore';\n\nconst nChartsPerPage = 3;\n\nconst aboveThresholdTarget = 7.2;\nconst belowThresholdTarget = 5;\n\nconst ExcludePrint = styled.div`\n  @media print {\n    display: none;\n  }\n`;\n\nconst ChartsContainer = styled.div`\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n`;\n\nconst ChartsHeading = styled.h1`\n  font-size: 2em;\n  padding: 25px;\n  @media print {\n    display: none;\n  }\n`;\n\nconst DateRangePickerContainer = styled.div`\n  padding: 25px;\n  @media print {\n    display: none;\n  }\n`;\n\nconst PageGroup = styled.div`\n  break-after: always;\n  break-inside: avoid;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-around;\n  width: 11in;\n\n  @media print {\n    height: 8.3in;\n    margin-bottom: 0.2in;\n  }\n`;\n\nconst ChartContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  margin: 0 20px;\n\n  &.hidden {\n    display: none;\n  }\n\n  @media print {\n    &.hidden {\n      display: flex;\n      visibility: hidden;\n    }\n  }\n`;\n\nconst ChartHeading = styled.h2`\n  font-weight: 600;\n  margin: 5px 0 0 0;\n  text-align: center;\n  text-transform: uppercase;\n`;\n\nconst Chart = styled.div`\n  flex: 1;\n`;\n\ntype DayData = {\n  day: string;\n  data: [number, number][];\n};\n\nexport type ChartsProps = React.HTMLAttributes<HTMLDivElement> & {\n  timezone: string;\n};\n\nexport const Charts: React.FC<ChartsProps> = ({ timezone, ...divProps }) => {\n  const metricsStore = React.useContext(MetricsStoreContext);\n  const [dayFilter, setDayFilter] = React.useState<Range>();\n\n  const [overallBloodGlucose] = useObservable(\n    () =>\n      metricsStore.bloodGlucose$.pipe(\n        map(MetricsStore.metricValuesToHighchartsPairs),\n      ),\n    [metricsStore],\n  );\n  const [overallMinMaxTime, setOverallMinMaxTime] =\n    React.useState<[number, number]>();\n  const overallHighchartsOptions = React.useMemo(() => {\n    return overallBloodGlucose !== undefined\n      ? createHighchartsOptionsOverall(\n          timezone,\n          overallBloodGlucose,\n          overallMinMaxTime !== undefined\n            ? { max: overallMinMaxTime[1], min: overallMinMaxTime[0] }\n            : undefined,\n        )\n      : undefined;\n  }, [overallBloodGlucose, overallMinMaxTime, timezone]);\n  const overallHighchartsFilterOptions = React.useMemo(\n    () =>\n      overallBloodGlucose !== undefined\n        ? createHighchartsOptionsOverall(\n            timezone,\n            overallBloodGlucose,\n            undefined,\n            (start, end) => setOverallMinMaxTime([start, end]),\n          )\n        : undefined,\n    [overallBloodGlucose, timezone],\n  );\n\n  const dailyBloodGlucose = React.useMemo(() => {\n    if (overallBloodGlucose !== undefined) {\n      return _.chain(overallBloodGlucose)\n        .groupBy(([time]) => moment(time).tz(timezone).format('YYYY-MM-DD'))\n        .toPairs()\n        .map(([day, data]) => ({ data, day }))\n        .sortBy('day')\n        .value();\n    } else {\n      return undefined;\n    }\n  }, [overallBloodGlucose, timezone]);\n  const dailyMinMaxDay = React.useMemo(() => {\n    if (dailyBloodGlucose !== undefined) {\n      const nDays = dailyBloodGlucose.length;\n      if (nDays > 0) {\n        return [\n          moment(dailyBloodGlucose[0].day, 'YYYY-MM-DD').tz(timezone),\n          moment(dailyBloodGlucose[nDays - 1].day, 'YYYY-MM-DD').tz(timezone),\n        ];\n      } else {\n        return undefined;\n      }\n    }\n  }, [dailyBloodGlucose, timezone]);\n  const dailyHighchartsOptions = React.useMemo(() => {\n    if (dailyBloodGlucose !== undefined) {\n      const filter = ({ day }: DayData) => {\n        if (\n          dayFilter !== undefined &&\n          dayFilter.startDate !== undefined &&\n          dayFilter.endDate !== undefined\n        ) {\n          const dayMoment = moment(day, 'YYYY-M-DD').tz(timezone);\n          return (\n            dayMoment.isSameOrAfter(dayFilter.startDate) &&\n            dayMoment.isSameOrBefore(dayFilter.endDate)\n          );\n        } else {\n          return true;\n        }\n      };\n\n      return _.chunk(\n        dailyBloodGlucose.filter(filter).map(({ data, day }) => {\n          const m = moment.tz(day, timezone);\n          const xMinMax = {\n            max: m.endOf('day').toDate().getTime(),\n            min: m.startOf('day').toDate().getTime(),\n          };\n          const yMax = Math.min(Math.max(8, ...data.map((d) => d[1])), 12);\n          const yMinMax = {\n            max: Math.ceil(yMax * 2) / 2,\n            min: 3,\n          };\n          return {\n            hidden: false,\n            options: createHighchartsOptionsForDay(\n              timezone,\n              data,\n              xMinMax,\n              yMinMax,\n            ),\n            title: m.format('dddd, MMMM Do YYYY'),\n          };\n        }),\n        nChartsPerPage,\n      );\n    } else {\n      return undefined;\n    }\n  }, [dailyBloodGlucose, dayFilter, timezone]);\n\n  return (\n    <ChartsContainer {...divProps}>\n      <ChartsHeading>Overall</ChartsHeading>\n      {overallHighchartsOptions !== undefined &&\n      overallHighchartsFilterOptions !== undefined ? (\n        <PageGroup key={`page-group-overall`}>\n          <ExcludePrint>\n            <HighchartsReact\n              id=\"overall-range-filter\"\n              constructorType=\"stockChart\"\n              highcharts={HighchartsStock}\n              options={overallHighchartsFilterOptions}\n            />\n          </ExcludePrint>\n          <ChartContainer>\n            <Chart>\n              <HighchartsReact\n                highcharts={Highcharts}\n                options={{ ...overallHighchartsOptions }}\n              />\n            </Chart>\n          </ChartContainer>\n        </PageGroup>\n      ) : undefined}\n      <ChartsHeading>Daily</ChartsHeading>\n      {dailyMinMaxDay !== undefined\n        ? (() => {\n            const [minDate, maxDate] = dailyMinMaxDay.map((m) => m.toDate());\n            return (\n              <DateRangePickerContainer>\n                <DateRangePicker\n                  maxDate={maxDate}\n                  minDate={minDate}\n                  moveRangeOnFirstSelection={false}\n                  onChange={(range) => {\n                    if ('selection' in range) {\n                      setDayFilter(range.selection);\n                    }\n                  }}\n                  ranges={[\n                    dayFilter === undefined\n                      ? {\n                          endDate: maxDate,\n                          key: 'selection',\n                          startDate: minDate,\n                        }\n                      : dayFilter,\n                  ]}\n                  showSelectionPreview={true}\n                />\n              </DateRangePickerContainer>\n            );\n          })()\n        : undefined}\n      {dailyHighchartsOptions !== undefined\n        ? dailyHighchartsOptions.map((pageGroup) => (\n            <PageGroup key={`page-group-${pageGroup[0].title}`}>\n              {pageGroup\n                .concat(\n                  // Concatenate dummy charts to fill up each page of 3. This ensures that 1 or\n                  // 2 charts on a page is always layed out the same way incrementally as a 3-chart\n                  // page. This is for print consistency when have 1 day, then 2, then 3 on a page.\n                  new Array(nChartsPerPage - pageGroup.length).fill({\n                    ...pageGroup[0],\n                    hidden: true,\n                    options: {\n                      ...pageGroup[0].options,\n                      chart: {\n                        ...pageGroup[0].options.chart,\n                        // Don't invoke any load events for the page-filler items\n                        events: {},\n                      },\n                    },\n                  }),\n                )\n                .map(({ hidden = false, title, options }, i) => {\n                  return (\n                    <ChartContainer\n                      className={hidden ? 'hidden' : 'visible'}\n                      key={i}\n                    >\n                      <ChartHeading>{title}</ChartHeading>\n                      <Chart>\n                        <HighchartsReact\n                          highcharts={Highcharts}\n                          key={`chart-${title}`}\n                          options={options}\n                        />\n                      </Chart>\n                    </ChartContainer>\n                  );\n                })}\n            </PageGroup>\n          ))\n        : undefined}\n    </ChartsContainer>\n  );\n};\n\nfunction createHighchartsOptionsOverall(\n  timezone: string,\n  data: [number, number][],\n  xMinMax?: { min: number; max: number },\n  onRangeChange?: (start: number, end: number) => void,\n): Highcharts.Options {\n  let rangeChangeTimeout: NodeJS.Timeout | undefined = undefined;\n  return {\n    chart: {\n      animation: false,\n      height: 225,\n      margin: [15, 0, 60, 40],\n      style: {\n        fontFamily: 'Poppins',\n      },\n      type: 'spline',\n    },\n    colors: ['rgba(255, 102, 102, 1)'],\n    credits: {\n      enabled: false,\n    },\n    legend: {\n      enabled: false,\n    },\n    plotOptions: {\n      series: {\n        gapSize: 30 * 60 * 1000,\n        gapUnit: 'value',\n        marker: {\n          enabled: false,\n        },\n      },\n    },\n    series: [\n      {\n        data,\n        name: 'mmol/L',\n        type: 'spline',\n      },\n    ],\n    time: {\n      moment,\n      timezone,\n    },\n    title: {\n      text: '',\n    },\n    xAxis: {\n      ...xMinMax,\n      dateTimeLabelFormats: {\n        day: \"%e. %b '%y\",\n        week: \"%e. %b '%y\",\n      },\n      events: {\n        setExtremes: (ev) => {\n          if (onRangeChange !== undefined) {\n            if (rangeChangeTimeout !== undefined) {\n              clearTimeout(rangeChangeTimeout);\n            }\n            rangeChangeTimeout = setTimeout(\n              () => onRangeChange(ev.min, ev.max),\n              500,\n            );\n          }\n        },\n      },\n      labels: {\n        rotation: -45,\n      },\n      ordinal: false,\n      type: 'datetime',\n    },\n    yAxis: {\n      plotBands: [\n        {\n          color: 'rgba(87, 220, 140, 0.2)',\n          from: 4.1,\n          to: 6,\n        },\n      ],\n      tickInterval: 0.5,\n      title: {\n        text: '',\n      },\n    },\n  };\n}\n\nfunction createHighchartsOptionsForDay(\n  timezone: string,\n  data: [number, number][],\n  xMinMax: { min: number; max: number },\n  yMinMax: {\n    min: number;\n    max: number;\n  },\n): Highcharts.Options {\n  const values = data.map((p) => p[1]);\n  const dayMax = Math.max(...values);\n  const dayAvg =\n    values.length > 0\n      ? Math.round(\n          (values.reduce((acc, v) => acc + v, 0) * 10) / values.length,\n        ) / 10\n      : undefined;\n  const dayMin = Math.min(...values);\n\n  const timeExposed = calculateTimeInRange(data, {\n    lower: aboveThresholdTarget,\n  });\n  const timeInRange = calculateTimeInRange(data, {\n    upper: belowThresholdTarget,\n  });\n\n  const labels: Highcharts.SVGElement[] = [];\n\n  return {\n    chart: {\n      events: {\n        render() {\n          labels.forEach((l) => l.destroy());\n          labels.length = 0;\n\n          const chartPaddingTop = 28.5;\n          const lineHeight = 18.5;\n          const labelX = 45;\n          const valueX = labelX + 140;\n\n          const attrs = {\n            fill: '#999',\n            'font-weight': '600',\n            zIndex: 1,\n          };\n\n          if (dayAvg !== undefined && dayMax !== undefined) {\n            const tirLabel = this.renderer\n              .text(`TIME IN RANGE (< ${belowThresholdTarget}):`, 0)\n              .add();\n            tirLabel.attr({\n              ...attrs,\n              x: labelX,\n              y: chartPaddingTop,\n            });\n            const tirValue = this.renderer\n              .text(\n                moment\n                  .duration(timeInRange, 'milliseconds')\n                  .format(() =>\n                    timeInRange > 60 * 60 * 1000 ? 'h[h] m[m]' : 'm[m]',\n                  ),\n                0,\n              )\n              .add();\n            tirValue.attr({\n              ...attrs,\n              x: valueX,\n              y: chartPaddingTop,\n            });\n\n            const maxLabel = this.renderer.text('MAXIMUM GLUCOSE:', 0).add();\n            maxLabel.attr({\n              ...attrs,\n              x: labelX,\n              y: chartPaddingTop + lineHeight,\n            });\n            const maxValue = this.renderer.text(dayMax.toString(), 0).add();\n            maxValue.attr({\n              ...attrs,\n              x: valueX,\n              y: chartPaddingTop + lineHeight,\n            });\n\n            const avgLabel = this.renderer.text('AVERAGE GLUCOSE:', 0).add();\n            avgLabel.attr({\n              ...attrs,\n              x: labelX,\n              y: chartPaddingTop + lineHeight * 2,\n            });\n            const avgValue = this.renderer.text(dayAvg.toString(), 0).add();\n            avgValue.attr({\n              ...attrs,\n              x: valueX,\n              y: chartPaddingTop + lineHeight * 2,\n            });\n\n            const teLabel = this.renderer\n              .text(`TIME EXPOSED (> ${aboveThresholdTarget}):`, 0)\n              .add();\n            teLabel.attr({\n              ...attrs,\n              x: labelX,\n              y: chartPaddingTop + lineHeight * 3,\n            });\n\n            const teValue = this.renderer\n              .text(\n                moment\n                  .duration(timeExposed, 'milliseconds')\n                  .format(() =>\n                    timeExposed > 60 * 60 * 1000 ? 'h[h] m[m]' : 'm[m]',\n                  ),\n                0,\n              )\n              .add();\n            teValue.attr({\n              ...attrs,\n              x: valueX,\n              y: chartPaddingTop + lineHeight * 3,\n            });\n\n            labels.push(\n              maxLabel,\n              maxValue,\n              avgLabel,\n              avgValue,\n              teLabel,\n              teValue,\n            );\n          }\n        },\n      },\n      height: 225,\n      margin: [15, 0, 30, 40],\n      style: {\n        fontFamily: 'Poppins',\n      },\n      type: 'spline',\n    },\n    colors: ['rgba(255, 102, 102, 1)'],\n    credits: {\n      enabled: false,\n    },\n    legend: {\n      enabled: false,\n    },\n    plotOptions: {\n      series: {\n        gapSize: 30 * 60 * 1000,\n        gapUnit: 'value',\n        marker: {\n          enabled: true,\n          radius: 2,\n        },\n      },\n    },\n    series: [\n      {\n        data,\n        name: 'mmol/L',\n        type: 'spline',\n      },\n    ],\n    time: {\n      moment,\n      timezone,\n    },\n    title: {\n      text: '',\n    },\n    xAxis: {\n      ...xMinMax,\n      dateTimeLabelFormats: {\n        day: '%H:%M',\n      },\n      type: 'datetime',\n    },\n    yAxis: {\n      ...yMinMax,\n      plotBands: [\n        {\n          color: 'rgba(87, 220, 140, 0.2)',\n          from: 4.1,\n          to: 6,\n        },\n      ],\n      plotLines: _.compact([\n        dayMax !== undefined\n          ? {\n              color: '#aaa',\n              dashStyle: 'Dot',\n              value: dayMax,\n              width: 2,\n              zIndex: 2,\n            }\n          : undefined,\n        {\n          color: 'rgba(65, 165, 105, 1)',\n          dashStyle: 'Dash',\n          value: 5,\n          width: 4,\n          zIndex: 2,\n        },\n        dayMin !== undefined\n          ? {\n              color: '#aaa',\n              dashStyle: 'Dot',\n              value: dayMin,\n              width: 2,\n              zIndex: 2,\n            }\n          : undefined,\n      ]),\n      tickInterval: 0.5,\n      title: {\n        text: '',\n      },\n    },\n  };\n}\n\nfunction calculateTimeInRange(\n  data: [number, number][],\n  { lower = Number.MIN_VALUE, upper = Number.MAX_VALUE } = {},\n): number {\n  return data.reduce((acc, [currTime, currValue], i) => {\n    if (i > 0) {\n      const [prevTime, prevValue] = data[i - 1];\n      const duration = currTime - prevTime;\n      const currValueLimited = Math.min(Math.max(currValue, lower), upper);\n      const prevValueLimited = Math.min(Math.max(prevValue, lower), upper);\n      const areaOfData =\n        (currTime - prevTime) * Math.abs(currValue - prevValue);\n      const areaInRange =\n        (currTime - prevTime) * Math.abs(currValueLimited - prevValueLimited);\n\n      if (areaOfData === 0 && currValueLimited !== currValue) {\n        // prevValue and currValue are the same, and they are not within range. 0 duration\n        return acc;\n      } else if (areaOfData === 0) {\n        // prevValue and currValue are the same, and they are within range. Full duration\n        return acc + duration;\n      } else {\n        // The value is different. The percentage of duration is the percentage of overlap\n        return acc + (areaInRange / areaOfData) * duration;\n      }\n    } else {\n      return 0;\n    }\n  }, 0);\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport type FileType = 'image' | 'csv';\n\nexport type File = {\n  contentType: string;\n  data: string;\n  name: string;\n  size: number;\n  type: FileType;\n};\n\nexport type ProcessedFiles = {\n  files: File[];\n  unsupported: string[];\n};\n\nexport const FileStoreContext = React.createContext<FileStore>(\n  undefined as unknown as FileStore,\n);\n\nexport class FileStore {\n  private readonly files$$ = new BehaviorSubject<File[]>([]);\n  public readonly files$ = this.files$$.asObservable();\n\n  public filesByType$(type: FileType): Observable<File[]> {\n    return this.files$.pipe(map((fs) => fs.filter((f) => f.type === type)));\n  }\n\n  public async preProcessFiles(fileList: FileList): Promise<ProcessedFiles> {\n    const files: File[] = [];\n    const unsupported: string[] = [];\n\n    for (let i = 0; i < fileList.length; i++) {\n      const fileListItem = fileList.item(i);\n      if (fileListItem !== null) {\n        const file = await this.preProcessFileData(\n          fileListItem.name,\n          fileListItem.type,\n          () => fileListItem.arrayBuffer(),\n        );\n\n        if (file !== undefined) {\n          files.push(file);\n        } else {\n          unsupported.push(fileListItem.name);\n        }\n      }\n    }\n    return { files, unsupported };\n  }\n\n  public async preProcessUrl(url: string): Promise<ProcessedFiles> {\n    const response = await fetch(url);\n    const contentType = response.headers.get('content-type');\n    const name = url.split('?')[0].split('/').slice(-1)[0];\n    const file = await this.preProcessFileData(\n      name,\n      contentType === null ? 'application/octet-stream' : contentType,\n      () => response.arrayBuffer(),\n    );\n    if (file !== undefined) {\n      return { files: [file], unsupported: [] };\n    } else {\n      return { files: [], unsupported: [url] };\n    }\n  }\n\n  public async acceptFiles(files: File[]): Promise<void> {\n    this.files$$.next(\n      _.chain(this.files$$.value).concat(files).uniqBy('data').value(),\n    );\n  }\n\n  private async preProcessFileData(\n    name: string,\n    contentType: string,\n    readData: () => Promise<ArrayBuffer>,\n  ): Promise<File | undefined> {\n    const type = resolveFileType(name, contentType);\n    if (type !== undefined) {\n      const buffer = await readData();\n      const data = base64EncodeBuffer(buffer);\n      const size = buffer.byteLength;\n      return { contentType, data, name, size, type };\n    } else {\n      return undefined;\n    }\n  }\n}\n\nfunction base64EncodeBuffer(buf: ArrayBuffer): string {\n  return btoa(\n    new Uint8Array(buf).reduce(\n      (str, byte) => str + String.fromCharCode(byte),\n      '',\n    ),\n  );\n}\n\nfunction resolveFileType(\n  name: string,\n  contentType: string,\n): FileType | undefined {\n  if (contentType.startsWith('text/csv')) {\n    return 'csv';\n  } else if (contentType.startsWith('image/')) {\n    return 'image';\n  } else if (contentType.startsWith('text/') && name.endsWith('csv')) {\n    return 'csv';\n  } else {\n    return undefined;\n  }\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nimport { useObservable } from '../hooks/useObservable';\nimport { FileStoreContext } from '../services/FileStore';\n\nconst Container = styled.div`\n  min-height: 100%;\n  min-width: 100%;\n  position: relative;\n`;\n\nexport const FileDropZone: React.FC = ({ children }) => {\n  const fileService = React.useContext(FileStoreContext);\n  const [files] = useObservable(() => fileService.files$, [fileService], []);\n  const [fileUploadEl, setFileUploadEl] = React.useState<HTMLInputElement>();\n  const handleSelectFiles = React.useCallback(\n    async (files: FileList) => {\n      const preProcessed = await fileService.preProcessFiles(files);\n      await fileService.acceptFiles(preProcessed.files);\n    },\n    [fileService],\n  );\n\n  return (\n    <Container\n      onClick={() =>\n        files.length === 0 && fileUploadEl !== undefined\n          ? fileUploadEl.click()\n          : undefined\n      }\n      onDragOver={(ev) => {\n        ev.preventDefault();\n        ev.stopPropagation();\n      }}\n      onDrop={(ev) => {\n        ev.preventDefault();\n        ev.stopPropagation();\n        void handleSelectFiles(ev.dataTransfer.files);\n      }}\n      style={{\n        cursor: files.length === 0 ? 'pointer' : undefined,\n      }}\n    >\n      <input\n        multiple\n        onChange={(ev) => {\n          const files = ev.target.files;\n          if (files !== null && files.length > 0) {\n            void handleSelectFiles(files);\n          }\n        }}\n        ref={(el) => (el !== null ? setFileUploadEl(el) : undefined)}\n        style={{ display: 'none' }}\n        type=\"file\"\n      />\n      {children}\n    </Container>\n  );\n};\n","import React from 'react';\nimport styled, { createGlobalStyle } from 'styled-components';\nimport reset from 'styled-reset';\n\nimport { Charts } from './components/Charts';\nimport { FileDropZone } from './components/FileDropZone';\nimport { useObservable } from './hooks/useObservable';\nimport { FileStore, FileStoreContext } from './services/FileStore';\nimport { MetricsStore, MetricsStoreContext } from './services/MetricsStore';\n\nconst GlobalStyle = createGlobalStyle`\n  /* Global reset to remove all browser styling. */\n  ${reset}\n\n  @page {\n    margin: 0;\n    size: landscape;\n  }\n\n  html,\n  body,\n  #root {\n    height: 100%;\n    width: 100%;\n  }\n\n  body {\n    font-family: 'Poppins', 'Roboto', 'Helvetica Neue', sans-serif;\n  }\n\n  #charts-for-print {\n    display: none;\n  }\n\n  @media print {\n    #charts-for-print {\n      display: block;\n    }\n\n    #charts-without-print {\n      display: none;\n    }\n\n    button.print {\n      display: none;\n    }\n  }\n`;\n\nconst Fullscreen = styled.div`\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  min-height: 100%;\n  position: absolute;\n  min-width: 100%;\n`;\n\nexport type AppProps = {\n  dataUrl: string | undefined;\n};\n\nconst App: React.FC<AppProps> = ({ dataUrl }) => {\n  const [fileStore] = React.useState(() => new FileStore());\n  const [metricsStore] = React.useState(() => new MetricsStore(fileStore));\n  const [csvFiles] = useObservable(\n    () => fileStore.filesByType$('csv'),\n    [fileStore],\n    [],\n  );\n\n  React.useEffect(() => {\n    if (dataUrl !== undefined) {\n      void (async () => {\n        const { files } = await fileStore.preProcessUrl(dataUrl);\n        await fileStore.acceptFiles(files);\n      })();\n    }\n  }, [dataUrl, fileStore]);\n\n  return (\n    <>\n      <GlobalStyle />\n      <FileStoreContext.Provider value={fileStore}>\n        <MetricsStoreContext.Provider value={metricsStore}>\n          <FileDropZone>\n            {csvFiles.length > 0 ? (\n              <Charts timezone=\"America/Toronto\" />\n            ) : dataUrl === undefined ? (\n              <Fullscreen>\n                <span>\n                  Drag and drop a Blood Glucose CSV file to view charts.\n                </span>\n              </Fullscreen>\n            ) : (\n              <Fullscreen>\n                <span>Downloading data...</span>\n              </Fullscreen>\n            )}\n          </FileDropZone>\n        </MetricsStoreContext.Provider>\n      </FileStoreContext.Provider>\n    </>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    void import('web-vitals').then(\n      ({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n        getCLS(onPerfEntry);\n        getFID(onPerfEntry);\n        getFCP(onPerfEntry);\n        getLCP(onPerfEntry);\n        getTTFB(onPerfEntry);\n      },\n    );\n  }\n};\n\nexport default reportWebVitals;\n","import * as Highcharts from 'highcharts';\nimport brokenAxis from 'highcharts/modules/broken-axis';\nimport 'moment-duration-format';\n\n/** React date range styles. */\nimport 'react-date-range/dist/styles.css';\nimport 'react-date-range/dist/theme/default.css';\n\n/** Highcharts setup. */\nbrokenAxis(Highcharts);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport './setupVendorLibraries';\n\nconst qs = new URLSearchParams(window.location.search);\nconst dataUrl = qs.get('dataUrl');\n\nReactDOM.render(\n  <React.StrictMode>\n    <App dataUrl={typeof dataUrl === 'string' ? dataUrl : undefined} />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}