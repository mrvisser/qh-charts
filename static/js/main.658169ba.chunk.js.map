{"version":3,"sources":["hooks/useObservable.ts","services/MetricsStore.ts","components/Charts.tsx","services/FileStore.ts","components/FileDropZone.tsx","App.tsx","reportWebVitals.ts","setupHighcharts.ts","index.tsx"],"names":["useObservable","observableGenerator","deps","initialValue","React","useState","value","setValue","cb","useCallback","useEffect","o","undefined","sub","subscribe","error","err","console","next","unsubscribe","MetricsStoreContext","createContext","MetricsStore","fileStore","customerDataTimeZone$$","BehaviorSubject","bloodGlucose$","combineLatest","this","filesByType$","pipe","concatMap","files","customerDataTimeZone","of","Promise","resolve","a","csvs","map","file","data","atob","bytes","Uint8Array","length","i","charCodeAt","TextDecoder","decode","all","parseBloodGlucoseCsv","timeValuesArr","timeValues","reduce","acc","m","Object","keys","timeStr","str","tz","time","moment","valueOf","sort","b","fn","input","accept","reject","csvParse","split","slice","join","columns","records","result","record","parseValue","parseFloat","isNaN","ChartsContainer","styled","div","PageGroup","ChartContainer","ChartHeading","h2","Chart","Charts","timezone","onAllChartsRendered","divProps","metricsStore","useContext","ms","_","chain","groupBy","format","toPairs","day","sortBy","curr","prevDay","currDay","nDaysMissing","diff","filler","Array","from","clone","add","concat","bloodGlucoseData","highchartsOptions","setHighchartsOptions","chartsRef","useRef","invokeOnAllChartsRendered","setInvokeOnAllChartsRendered","renderedChartIndexes","setRenderedChartIndexes","yMinMax","max","min","chunk","xMinMax","endOf","toDate","getTime","startOf","hidden","options","createHighchartsOptionsForDay","rci","title","pageGroup","fill","chart","events","className","callback","current","highcharts","Highcharts","onLoad","values","p","dayMax","Math","dayAvg","round","v","dayMin","labels","calledOnLoad","load","render","forEach","l","destroy","chartPaddingTop","attrs","zIndex","avgLabel","renderer","text","attr","x","y","avgValue","toString","labelX","maxLabel","maxValue","push","height","margin","style","fontFamily","type","colors","credits","enabled","legend","plotOptions","series","gapSize","gapUnit","marker","radius","name","xAxis","dateTimeLabelFormats","yAxis","plotBands","color","to","plotLines","compact","dashStyle","width","tickInterval","FileStoreContext","FileStore","files$$","files$","asObservable","fs","filter","f","fileList","unsupported","fileListItem","item","preProcessFileData","arrayBuffer","url","fetch","response","contentType","headers","get","uniqBy","readData","resolveFileType","buffer","btoa","byte","String","fromCharCode","size","byteLength","startsWith","endsWith","Container","FileDropZone","children","fileService","fileUploadEl","setFileUploadEl","handleSelectFiles","preProcessFiles","preProcessed","acceptFiles","onClick","click","onDragOver","ev","preventDefault","stopPropagation","onDrop","dataTransfer","cursor","multiple","onChange","target","ref","el","display","GlobalStyle","createGlobalStyle","reset","Fullscreen","App","dataUrl","csvFiles","preProcessUrl","Provider","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","brokenAxis","timezoneOffset","getTimezoneOffset","URLSearchParams","window","location","search","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.658169ba.chunk.js","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\nimport React from 'react';\nimport { Observable } from 'rxjs';\n\nexport type ObserverFunction<T> = () => Observable<T> | undefined;\n\n/** @see [useObservable(observableGenerator, deps, initialvalue?)] */\nexport function useObservable<T>(\n  observableGenerator: ObserverFunction<T>,\n  deps: React.DependencyList,\n): [T | undefined];\n\n/** @see [useObservable(observableGenerator, deps, initialvalue?)] */\nexport function useObservable<T>(\n  observableGenerator: ObserverFunction<T>,\n  deps: React.DependencyList,\n  initialValue: T,\n): [T];\n\n/**\n * A custom hook that exposes an observable as its latest emitted value.\n *\n * @param observableGenerator A factory function for the observable\n * @param deps The dependency array. When any of these dependencies changes, the observable will\n *   be regenerated.\n * @param initialValue The initial value of the observable value, before it emits its first value.\n *   When the dependency array changes, the value will not revert to the initial value.\n * @returns\n */\nexport function useObservable<T>(\n  observableGenerator: ObserverFunction<T>,\n  deps: React.DependencyList,\n  initialValue?: T,\n): [typeof initialValue] {\n  const [value, setValue] = React.useState<T | typeof initialValue>(\n    initialValue,\n  );\n  const cb = React.useCallback(observableGenerator, deps);\n\n  /** When the callback changes, reinvoke it and subscribe to the new observable. */\n  React.useEffect(() => {\n    const o = cb();\n    if (o !== undefined) {\n      // eslint-disable-next-line deprecation/deprecation\n      const sub = o.subscribe({\n        // eslint-disable-next-line no-console\n        error: (err) => console.error(err),\n        next: setValue,\n      });\n      return () => sub.unsubscribe();\n    }\n  }, [cb]);\n\n  return [value];\n}\n","import csvParse from 'csv-parse';\nimport moment from 'moment-timezone';\nimport React from 'react';\nimport { BehaviorSubject, combineLatest, Observable, of } from 'rxjs';\nimport { concatMap } from 'rxjs/operators';\n\nimport { FileStore } from './FileStore';\n\nexport type MetricValue<T> = {\n  time: number;\n  value: T;\n};\n\ntype CsvRecord = {\n  'Device Timestamp': string;\n  'Record Type': string;\n  'Historic Glucose mmol/L': string;\n  'Scan Glucose mmol/L': string;\n};\n\nexport const MetricsStoreContext = React.createContext<MetricsStore>(\n  (undefined as unknown) as MetricsStore,\n);\n\nexport class MetricsStore {\n  private customerDataTimeZone$$ = new BehaviorSubject('America/Toronto');\n\n  constructor(private readonly fileStore: FileStore) {}\n\n  /** Observe changes to the blood glucose metrics. */\n  public readonly bloodGlucose$: Observable<\n    MetricValue<number>[] | undefined\n  > = combineLatest([\n    this.fileStore.filesByType$('csv'),\n    this.customerDataTimeZone$$,\n  ])\n    .pipe(\n      concatMap(([files, customerDataTimeZone]) =>\n        of<() => Promise<MetricValue<number>[] | undefined>>(\n          () => Promise.resolve(undefined),\n          async () => {\n            const csvs = files.map((file) => {\n              const data = atob(file.data);\n              const bytes = new Uint8Array(data.length);\n              for (let i = 0; i < data.length; i++) {\n                bytes[i] = data.charCodeAt(i);\n              }\n              return new TextDecoder('utf-8').decode(bytes);\n            });\n            const timeValuesArr: Record<string, number>[] = await Promise.all(\n              csvs.map(parseBloodGlucoseCsv),\n            );\n            const timeValues = timeValuesArr.reduce(\n              (acc, m) => ({ ...acc, ...m }),\n              {},\n            );\n            return Object.keys(timeValues)\n              .map((timeStr) => {\n                const value = timeValues[timeStr];\n                const time = parseTime(timeStr, customerDataTimeZone);\n                return { time, value };\n              })\n              .sort((a, b) => a.time - b.time);\n          },\n        ),\n      ),\n    )\n    .pipe(concatMap((fn) => fn()));\n}\n\nfunction parseBloodGlucoseCsv(input: string): Promise<Record<string, number>> {\n  return new Promise((accept, reject) => {\n    csvParse(\n      input.split('\\n').slice(1).join('\\n'),\n      { columns: true },\n      (err, records: CsvRecord[]) => {\n        if (err !== undefined) {\n          return reject(err);\n        }\n\n        const result: Record<string, number> = {};\n        for (const record of records) {\n          const value = parseValue(record);\n          if (value !== undefined) {\n            result[record['Device Timestamp']] = value;\n          }\n        }\n\n        accept(result);\n      },\n    );\n  });\n}\n\nfunction parseTime(str: string, tz: string): number {\n  return moment.tz(str, 'DD-MM-YYYY HH:mm', tz).valueOf();\n}\n\nfunction parseValue(record: CsvRecord): number | undefined {\n  const value =\n    record['Record Type'] === '0'\n      ? parseFloat(record['Historic Glucose mmol/L'])\n      : parseFloat(record['Scan Glucose mmol/L']);\n  if (!isNaN(value)) {\n    return value;\n  } else {\n    return undefined;\n  }\n}\n","import * as Highcharts from 'highcharts';\nimport HighchartsReact from 'highcharts-react-official';\nimport _ from 'lodash';\nimport moment, { Moment } from 'moment-timezone';\nimport React from 'react';\nimport { map } from 'rxjs/operators';\nimport styled from 'styled-components';\n\nimport { useObservable } from '../hooks/useObservable';\nimport { MetricsStoreContext } from '../services/MetricsStore';\n\nconst nChartsPerPage = 3;\n\nconst ChartsContainer = styled.div`\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n`;\n\nconst PageGroup = styled.div`\n  break-after: always;\n  break-inside: avoid;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-around;\n  width: 11in;\n\n  @media print {\n    height: 8.3in;\n    margin-bottom: 0.2in;\n  }\n`;\n\nconst ChartContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  margin: 0 20px;\n\n  &.hidden {\n    display: none;\n  }\n\n  @media print {\n    &.hidden {\n      display: flex;\n      visibility: hidden;\n    }\n  }\n`;\n\nconst ChartHeading = styled.h2`\n  font-weight: 600;\n  margin: 5px 0 0 0;\n  text-align: center;\n  text-transform: uppercase;\n`;\n\nconst Chart = styled.div`\n  flex: 1;\n`;\n\ntype DayData = {\n  day: string;\n  data: (readonly [number, number])[];\n};\n\nexport type ChartsProps = React.HTMLAttributes<HTMLDivElement> & {\n  timezone: string;\n  onAllChartsRendered?: () => void;\n};\n\nexport const Charts: React.FC<ChartsProps> = ({\n  timezone,\n  onAllChartsRendered,\n  ...divProps\n}) => {\n  const metricsStore = React.useContext(MetricsStoreContext);\n  const [bloodGlucoseData] = useObservable(\n    () =>\n      metricsStore.bloodGlucose$\n        .pipe(\n          map((ms) =>\n            ms !== undefined\n              ? ms.map(({ time, value }) => [time, value] as const)\n              : undefined,\n          ),\n        )\n        .pipe(\n          map((ms) => {\n            if (ms !== undefined) {\n              const dayData = _.chain(ms)\n                .groupBy(([time]) =>\n                  moment(time).tz(timezone).format('YYYY-MM-DD'),\n                )\n                .toPairs()\n                .map(([day, data]) => ({ data, day }))\n                .sortBy('day')\n                .value();\n              return dayData.reduce<{\n                acc: DayData[];\n                prevDay: Moment | undefined;\n              }>(\n                ({ acc, prevDay }, curr) => {\n                  const currDay = moment(curr.day, 'YYYY-MM-DD');\n                  if (prevDay !== undefined) {\n                    // If there is 1 or more days in between this day and the next day, then fill\n                    // in the empty days with no data. This ensures that we just render empty\n                    // graphs in between\n                    const nDaysMissing = currDay.diff(prevDay, 'days') - 1;\n                    const filler = Array.from(Array(nDaysMissing).keys()).map(\n                      (i): DayData => ({\n                        data: [],\n                        day: prevDay\n                          .clone()\n                          .add(i + 1, 'days')\n                          .format('YYYY-MM-DD'),\n                      }),\n                    );\n                    return {\n                      acc: acc.concat(filler, [curr]),\n                      prevDay: currDay,\n                    };\n                  } else {\n                    return { acc: [curr], prevDay: currDay };\n                  }\n                },\n                { acc: [], prevDay: undefined },\n              ).acc;\n            } else {\n              return undefined;\n            }\n          }),\n        ),\n    [metricsStore, timezone],\n  );\n  const [highchartsOptions, setHighchartsOptions] = React.useState<\n    {\n      hidden: boolean;\n      options: Highcharts.Options;\n      title: string;\n    }[][]\n  >();\n  const chartsRef = React.useRef<{ [title: string]: Highcharts.Chart }>({});\n\n  const [\n    invokeOnAllChartsRendered,\n    setInvokeOnAllChartsRendered,\n  ] = React.useState(true);\n  const [renderedChartIndexes, setRenderedChartIndexes] = React.useState<\n    Record<number, true>\n  >({});\n\n  React.useEffect(() => {\n    if (bloodGlucoseData !== undefined) {\n      const min = 3;\n      const max = 8;\n      const yMinMax = { max, min };\n      setRenderedChartIndexes({});\n      setHighchartsOptions(\n        _.chunk(\n          bloodGlucoseData.map(({ data, day }, i) => {\n            const m = moment.tz(day, timezone);\n            const xMinMax = {\n              max: m.endOf('day').toDate().getTime(),\n              min: m.startOf('day').toDate().getTime(),\n            };\n            return {\n              hidden: false,\n              options: createHighchartsOptionsForDay(\n                timezone,\n                data,\n                xMinMax,\n                yMinMax,\n                () => setRenderedChartIndexes((rci) => ({ ...rci, [i]: true })),\n              ),\n              title: m.format('dddd, MMMM Do'),\n            };\n          }),\n          nChartsPerPage,\n        ),\n      );\n    } else {\n      setHighchartsOptions(undefined);\n    }\n  }, [bloodGlucoseData, timezone]);\n\n  React.useEffect(() => {\n    if (\n      invokeOnAllChartsRendered &&\n      onAllChartsRendered !== undefined &&\n      bloodGlucoseData !== undefined\n    ) {\n      const areAllChartsRendered =\n        Object.keys(renderedChartIndexes).length === bloodGlucoseData.length;\n      if (areAllChartsRendered) {\n        setInvokeOnAllChartsRendered(false);\n        onAllChartsRendered();\n      }\n    }\n  }, [\n    bloodGlucoseData,\n    invokeOnAllChartsRendered,\n    onAllChartsRendered,\n    renderedChartIndexes,\n  ]);\n\n  return (\n    <ChartsContainer {...divProps}>\n      {highchartsOptions !== undefined\n        ? highchartsOptions.map((pageGroup) => (\n            <PageGroup key={`page-group-${pageGroup[0].title}`}>\n              {pageGroup\n                .concat(\n                  // Concatenate dummy charts to fill up each page of 3. This ensures that 1 or\n                  // 2 charts on a page is always layed out the same way incrementally as a 3-chart\n                  // page. This is for print consistency when have 1 day, then 2, then 3 on a page.\n                  new Array(nChartsPerPage - pageGroup.length).fill({\n                    ...pageGroup[0],\n                    hidden: true,\n                    options: {\n                      ...pageGroup[0].options,\n                      chart: {\n                        ...pageGroup[0].options.chart,\n                        // Don't invoke any load events for the page-filler items\n                        events: {},\n                      },\n                    },\n                  }),\n                )\n                .map(({ hidden = false, title, options }, i) => {\n                  return (\n                    <ChartContainer\n                      className={hidden ? 'hidden' : 'visible'}\n                      key={i}\n                    >\n                      <ChartHeading>{title}</ChartHeading>\n                      <Chart>\n                        <HighchartsReact\n                          callback={(chart: Highcharts.Chart) => {\n                            chartsRef.current[title] = chart;\n                          }}\n                          highcharts={Highcharts}\n                          key={`chart-${title}`}\n                          options={options}\n                        />\n                      </Chart>\n                    </ChartContainer>\n                  );\n                })}\n            </PageGroup>\n          ))\n        : undefined}\n    </ChartsContainer>\n  );\n};\n\nfunction createHighchartsOptionsForDay(\n  timezone: string,\n  data: (readonly [number, number])[],\n  xMinMax: { min: number; max: number },\n  yMinMax: {\n    min: number;\n    max: number;\n  },\n  onLoad: () => void,\n): Highcharts.Options {\n  const values = data.map((p) => p[1]);\n  const dayMax = Math.max(...values);\n  const dayAvg =\n    values.length > 0\n      ? Math.round(\n          (values.reduce((acc, v) => acc + v, 0) * 10) / values.length,\n        ) / 10\n      : undefined;\n  const dayMin = Math.min(...values);\n  const labels: Highcharts.SVGElement[] = [];\n  let calledOnLoad = false;\n\n  return {\n    chart: {\n      events: {\n        load() {\n          if (!calledOnLoad) {\n            calledOnLoad = true;\n            onLoad();\n          }\n        },\n        render() {\n          labels.forEach((l) => l.destroy());\n          labels.length = 0;\n\n          const chartPaddingTop = 28.5;\n          const lineHeight = 18.5;\n          const labelX = 45;\n          const valueX = labelX + 140;\n\n          const attrs = {\n            fill: '#999',\n            'font-weight': '600',\n            zIndex: 1,\n          };\n\n          if (dayAvg !== undefined && dayMax !== undefined) {\n            const avgLabel = this.renderer.text('AVERAGE GLUCOSE:', 0).add();\n            avgLabel.attr({\n              ...attrs,\n              x: labelX,\n              y: chartPaddingTop,\n            });\n            const avgValue = this.renderer.text(dayAvg.toString(), 0).add();\n\n            avgValue.attr({\n              ...attrs,\n              x: valueX,\n              y: chartPaddingTop,\n            });\n\n            const maxLabel = this.renderer.text('MAXIMUM GLUCOSE:', 0).add();\n            maxLabel.attr({\n              ...attrs,\n              x: labelX,\n              y: chartPaddingTop + lineHeight,\n            });\n            const maxValue = this.renderer.text(dayMax.toString(), 0).add();\n            maxValue.attr({\n              ...attrs,\n              x: valueX,\n              y: chartPaddingTop + lineHeight,\n            });\n\n            labels.push(avgLabel, avgValue, maxLabel, maxValue);\n          }\n        },\n      },\n      height: 225,\n      margin: [15, 0, 30, 40],\n      style: {\n        fontFamily: 'Poppins',\n      },\n      type: 'spline',\n    },\n    colors: ['rgba(255, 102, 102, 1)'],\n    credits: {\n      enabled: false,\n    },\n    legend: {\n      enabled: false,\n    },\n    plotOptions: {\n      series: {\n        gapSize: 30 * 60 * 1000,\n        gapUnit: 'value',\n        marker: {\n          enabled: true,\n          radius: 2,\n        },\n      },\n    },\n    series: [\n      {\n        data,\n        name: 'mmol/L',\n        type: 'spline',\n      },\n    ],\n    time: {\n      moment,\n      timezone,\n    },\n    title: {\n      text: '',\n    },\n    xAxis: {\n      ...xMinMax,\n      dateTimeLabelFormats: {\n        day: '%H:%M',\n      },\n      type: 'datetime',\n    },\n    yAxis: {\n      ...yMinMax,\n      plotBands: [\n        {\n          color: 'rgba(87, 220, 140, 0.2)',\n          from: 4.1,\n          to: 6,\n        },\n      ],\n      plotLines: _.compact([\n        dayMax !== undefined\n          ? {\n              color: '#aaa',\n              dashStyle: 'Dot',\n              value: dayMax,\n              width: 2,\n              zIndex: 2,\n            }\n          : undefined,\n        {\n          color: '#aaa',\n          dashStyle: 'Dash',\n          value: 5,\n          width: 4,\n          zIndex: 2,\n        },\n        dayMin !== undefined\n          ? {\n              color: '#aaa',\n              dashStyle: 'Dot',\n              value: dayMin,\n              width: 2,\n              zIndex: 2,\n            }\n          : undefined,\n      ]),\n      tickInterval: 0.5,\n      title: {\n        text: '',\n      },\n    },\n  };\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport type FileType = 'image' | 'csv';\n\nexport type File = {\n  contentType: string;\n  data: string;\n  name: string;\n  size: number;\n  type: FileType;\n};\n\nexport type ProcessedFiles = {\n  files: File[];\n  unsupported: string[];\n};\n\nexport const FileStoreContext = React.createContext<FileStore>(\n  (undefined as unknown) as FileStore,\n);\n\nexport class FileStore {\n  private readonly files$$ = new BehaviorSubject<File[]>([]);\n  public readonly files$ = this.files$$.asObservable();\n\n  public filesByType$(type: FileType): Observable<File[]> {\n    return this.files$.pipe(map((fs) => fs.filter((f) => f.type === type)));\n  }\n\n  public async preProcessFiles(fileList: FileList): Promise<ProcessedFiles> {\n    const files: File[] = [];\n    const unsupported: string[] = [];\n\n    for (let i = 0; i < fileList.length; i++) {\n      const fileListItem = fileList.item(i);\n      if (fileListItem !== null) {\n        const file = await this.preProcessFileData(\n          fileListItem.name,\n          fileListItem.type,\n          () => fileListItem.arrayBuffer(),\n        );\n\n        if (file !== undefined) {\n          files.push(file);\n        } else {\n          unsupported.push(fileListItem.name);\n        }\n      }\n    }\n    return { files, unsupported };\n  }\n\n  public async preProcessUrl(url: string): Promise<ProcessedFiles> {\n    const response = await fetch(url);\n    const contentType = response.headers.get('content-type');\n    const name = url.split('?')[0].split('/').slice(-1)[0];\n    const file = await this.preProcessFileData(\n      name,\n      contentType === null ? 'application/octet-stream' : contentType,\n      () => response.arrayBuffer(),\n    );\n    if (file !== undefined) {\n      return { files: [file], unsupported: [] };\n    } else {\n      return { files: [], unsupported: [url] };\n    }\n  }\n\n  public async acceptFiles(files: File[]): Promise<void> {\n    this.files$$.next(\n      _.chain(this.files$$.value).concat(files).uniqBy('data').value(),\n    );\n  }\n\n  private async preProcessFileData(\n    name: string,\n    contentType: string,\n    readData: () => Promise<ArrayBuffer>,\n  ): Promise<File | undefined> {\n    const type = resolveFileType(name, contentType);\n    if (type !== undefined) {\n      const buffer = await readData();\n      const data = base64EncodeBuffer(buffer);\n      const size = buffer.byteLength;\n      return { contentType, data, name, size, type };\n    } else {\n      return undefined;\n    }\n  }\n}\n\nfunction base64EncodeBuffer(buf: ArrayBuffer): string {\n  return btoa(\n    new Uint8Array(buf).reduce(\n      (str, byte) => str + String.fromCharCode(byte),\n      '',\n    ),\n  );\n}\n\nfunction resolveFileType(\n  name: string,\n  contentType: string,\n): FileType | undefined {\n  if (contentType.startsWith('text/csv')) {\n    return 'csv';\n  } else if (contentType.startsWith('image/')) {\n    return 'image';\n  } else if (contentType.startsWith('text/') && name.endsWith('csv')) {\n    return 'csv';\n  } else {\n    return undefined;\n  }\n}\n","/* eslint-disable no-console */\nimport React from 'react';\nimport styled from 'styled-components';\n\nimport { useObservable } from '../hooks/useObservable';\nimport { FileStoreContext } from '../services/FileStore';\n\nconst Container = styled.div`\n  min-height: 100%;\n  min-width: 100%;\n  position: relative;\n`;\n\nexport const FileDropZone: React.FC = ({ children }) => {\n  const fileService = React.useContext(FileStoreContext);\n  const [files] = useObservable(() => fileService.files$, [fileService], []);\n  const [fileUploadEl, setFileUploadEl] = React.useState<HTMLInputElement>();\n  const handleSelectFiles = React.useCallback(\n    async (files: FileList) => {\n      const preProcessed = await fileService.preProcessFiles(files);\n      await fileService.acceptFiles(preProcessed.files);\n    },\n    [fileService],\n  );\n\n  return (\n    <Container\n      onClick={() =>\n        files.length === 0 && fileUploadEl !== undefined\n          ? fileUploadEl.click()\n          : undefined\n      }\n      onDragOver={(ev) => {\n        ev.preventDefault();\n        ev.stopPropagation();\n      }}\n      onDrop={(ev) => {\n        ev.preventDefault();\n        ev.stopPropagation();\n        void handleSelectFiles(ev.dataTransfer.files);\n      }}\n      style={{\n        cursor: files.length === 0 ? 'pointer' : undefined,\n      }}\n    >\n      <input\n        multiple\n        onChange={(ev) => {\n          const files = ev.target.files;\n          if (files !== null && files.length > 0) {\n            void handleSelectFiles(files);\n          }\n        }}\n        ref={(el) => (el !== null ? setFileUploadEl(el) : undefined)}\n        style={{ display: 'none' }}\n        type=\"file\"\n      />\n      {children}\n    </Container>\n  );\n};\n","import React from 'react';\nimport styled, { createGlobalStyle } from 'styled-components';\nimport reset from 'styled-reset';\n\nimport { Charts } from './components/Charts';\nimport { FileDropZone } from './components/FileDropZone';\nimport { useObservable } from './hooks/useObservable';\nimport { FileStore, FileStoreContext } from './services/FileStore';\nimport { MetricsStore, MetricsStoreContext } from './services/MetricsStore';\n\nconst GlobalStyle = createGlobalStyle`\n  /* Global reset to remove all browser styling. */\n  ${reset}\n\n  @page {\n    margin: 0;\n    size: landscape;\n  }\n\n  html,\n  body,\n  #root {\n    height: 100%;\n    width: 100%;\n  }\n\n  body {\n    font-family: 'Poppins', 'Roboto', 'Helvetica Neue', sans-serif;\n  }\n\n  #charts-for-print {\n    display: none;\n  }\n\n  @media print {\n    #charts-for-print {\n      display: block;\n    }\n\n    #charts-without-print {\n      display: none;\n    }\n\n    button.print {\n      display: none;\n    }\n  }\n`;\n\nconst Fullscreen = styled.div`\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  min-height: 100%;\n  position: absolute;\n  min-width: 100%;\n`;\n\nexport type AppProps = {\n  dataUrl: string | undefined;\n};\n\nconst App: React.FC<AppProps> = ({ dataUrl }) => {\n  const [fileStore] = React.useState(() => new FileStore());\n  const [metricsStore] = React.useState(() => new MetricsStore(fileStore));\n  const [csvFiles] = useObservable(\n    () => fileStore.filesByType$('csv'),\n    [fileStore],\n    [],\n  );\n\n  React.useEffect(() => {\n    if (dataUrl !== undefined) {\n      void (async () => {\n        const { files } = await fileStore.preProcessUrl(dataUrl);\n        await fileStore.acceptFiles(files);\n      })();\n    }\n  }, [dataUrl, fileStore]);\n\n  return (\n    <>\n      <GlobalStyle />\n      <FileStoreContext.Provider value={fileStore}>\n        <MetricsStoreContext.Provider value={metricsStore}>\n          <FileDropZone>\n            {csvFiles.length > 0 ? (\n              <Charts timezone=\"America/Toronto\" />\n            ) : dataUrl === undefined ? (\n              <Fullscreen>\n                <span>\n                  Drag and drop a Blood Glucose CSV file to view charts.\n                </span>\n              </Fullscreen>\n            ) : (\n              <Fullscreen>\n                <span>Downloading data...</span>\n              </Fullscreen>\n            )}\n          </FileDropZone>\n        </MetricsStoreContext.Provider>\n      </FileStoreContext.Provider>\n    </>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    void import('web-vitals').then(\n      ({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n        getCLS(onPerfEntry);\n        getFID(onPerfEntry);\n        getFCP(onPerfEntry);\n        getLCP(onPerfEntry);\n        getTTFB(onPerfEntry);\n      },\n    );\n  }\n};\n\nexport default reportWebVitals;\n","import * as Highcharts from 'highcharts';\nimport brokenAxis from 'highcharts/modules/broken-axis';\nimport moment from 'moment-timezone';\n\nbrokenAxis(Highcharts);\nHighcharts.setOptions({\n  time: {\n    timezoneOffset: moment.tz('America/Toronto').toDate().getTimezoneOffset(),\n  },\n});\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport './setupHighcharts';\n\nconst qs = new URLSearchParams(window.location.search);\nconst dataUrl = qs.get('dataUrl');\n\nReactDOM.render(\n  <React.StrictMode>\n    <App dataUrl={typeof dataUrl === 'string' ? dataUrl : undefined} />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}